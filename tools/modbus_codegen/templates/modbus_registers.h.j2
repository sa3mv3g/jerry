/**
 * @file {{ config.device.name | lower }}_registers.h
 * @brief Modbus register definitions for {{ config.device.name }}
 *
 * This file is auto-generated by modbus_codegen.py
 * DO NOT EDIT MANUALLY
 *
 * Device: {{ config.device.name }}
 * Description: {{ config.device.description | default("") }}
 * Version: {{ config.device.version | default("1.0.0") }}
 *
 * @copyright Copyright (c) 2026
 */

#ifndef {{ config.device.name | upper }}_REGISTERS_H
#define {{ config.device.name | upper }}_REGISTERS_H

#include <stdint.h>
#include <stdbool.h>

/* ==========================================================================
 * Device Configuration
 * ========================================================================== */

/** Default Modbus slave ID */
#define {{ config.device.name | upper }}_DEFAULT_SLAVE_ID    {{ config.device.slave_id }}

/* ==========================================================================
 * Register Statistics
 * ========================================================================== */

/** Number of coils */
#define {{ config.device.name | upper }}_NUM_COILS           {{ config.stats.num_coils }}

/** Number of discrete inputs */
#define {{ config.device.name | upper }}_NUM_DISCRETE_INPUTS {{ config.stats.num_discrete_inputs }}

/** Number of holding registers */
#define {{ config.device.name | upper }}_NUM_HOLDING_REGS    {{ config.stats.num_holding_registers }}

/** Number of input registers */
#define {{ config.device.name | upper }}_NUM_INPUT_REGS      {{ config.stats.num_input_registers }}

{% if config.stats.num_coils > 0 %}
/* ==========================================================================
 * Coil Addresses (FC01, FC05, FC15)
 * ========================================================================== */

{% for coil in config.registers.coils %}
/** {{ coil.description | default(coil.name) }} */
#define {{ config.device.name | upper }}_COIL_{{ coil.name | upper }}    {{ coil.address }}U
{% endfor %}

/** Coil address range */
#define {{ config.device.name | upper }}_COIL_MIN_ADDR       {{ config.stats.coils_min_addr }}U
#define {{ config.device.name | upper }}_COIL_MAX_ADDR       {{ config.stats.coils_max_addr }}U

{% endif %}
{% if config.stats.num_discrete_inputs > 0 %}
/* ==========================================================================
 * Discrete Input Addresses (FC02)
 * ========================================================================== */

{% for di in config.registers.discrete_inputs %}
/** {{ di.description | default(di.name) }} */
#define {{ config.device.name | upper }}_DI_{{ di.name | upper }}    {{ di.address }}U
{% endfor %}

/** Discrete input address range */
#define {{ config.device.name | upper }}_DI_MIN_ADDR         {{ config.stats.discrete_inputs_min_addr }}U
#define {{ config.device.name | upper }}_DI_MAX_ADDR         {{ config.stats.discrete_inputs_max_addr }}U

{% endif %}
{% if config.stats.num_holding_registers > 0 %}
/* ==========================================================================
 * Holding Register Addresses (FC03, FC06, FC16)
 * ========================================================================== */

{% for reg in config.registers.holding_registers %}
/** {{ reg.description | default(reg.name) }}{% if reg.unit %} [{{ reg.unit }}]{% endif %} */
#define {{ config.device.name | upper }}_HR_{{ reg.name | upper }}    {{ reg.address }}U
{% if reg.size > 1 %}
#define {{ config.device.name | upper }}_HR_{{ reg.name | upper }}_SIZE    {{ reg.size }}U
{% endif %}
{% endfor %}

/** Holding register address range */
#define {{ config.device.name | upper }}_HR_MIN_ADDR         {{ config.stats.holding_registers_min_addr }}U
#define {{ config.device.name | upper }}_HR_MAX_ADDR         {{ config.stats.holding_registers_max_addr }}U

{% endif %}
{% if config.stats.num_input_registers > 0 %}
/* ==========================================================================
 * Input Register Addresses (FC04)
 * ========================================================================== */

{% for reg in config.registers.input_registers %}
/** {{ reg.description | default(reg.name) }}{% if reg.unit %} [{{ reg.unit }}]{% endif %} */
#define {{ config.device.name | upper }}_IR_{{ reg.name | upper }}    {{ reg.address }}U
{% if reg.size > 1 %}
#define {{ config.device.name | upper }}_IR_{{ reg.name | upper }}_SIZE    {{ reg.size }}U
{% endif %}
{% endfor %}

/** Input register address range */
#define {{ config.device.name | upper }}_IR_MIN_ADDR         {{ config.stats.input_registers_min_addr }}U
#define {{ config.device.name | upper }}_IR_MAX_ADDR         {{ config.stats.input_registers_max_addr }}U

{% endif %}
{% if config.enums %}
/* ==========================================================================
 * Enumeration Types
 * ========================================================================== */

{% for enum in config.enums %}
/**
 * @brief {{ enum.description | default(enum.name) }}
 */
typedef enum {
{% for value in enum.values %}
    {{ config.device.name | upper }}_{{ enum.name | upper }}_{{ value.name | upper }} = {{ value.value }}{% if not loop.last %},{% endif %}  /**< {{ value.description | default(value.name) }} */
{% endfor %}
} {{ config.device.name | lower }}_{{ enum.name | lower }}_t;

{% endfor %}
{% endif %}
/* ==========================================================================
 * Register Data Structures
 * ========================================================================== */

{% if config.stats.num_coils > 0 %}
/**
 * @brief Coil data storage
 */
typedef struct {
{% for coil in config.registers.coils %}
    bool {{ coil.name | lower }};  /**< {{ coil.description | default(coil.name) }} */
{% endfor %}
} {{ config.device.name | lower }}_coils_t;

{% endif %}
{% if config.stats.num_discrete_inputs > 0 %}
/**
 * @brief Discrete input data storage
 */
typedef struct {
{% for di in config.registers.discrete_inputs %}
    bool {{ di.name | lower }};  /**< {{ di.description | default(di.name) }} */
{% endfor %}
} {{ config.device.name | lower }}_discrete_inputs_t;

{% endif %}
{% if config.stats.num_holding_registers > 0 %}
/**
 * @brief Holding register data storage
 */
typedef struct {
{% for reg in config.registers.holding_registers %}
{% if reg.data_type == "uint16" %}
    uint16_t {{ reg.name | lower }};  /**< {{ reg.description | default(reg.name) }} */
{% elif reg.data_type == "int16" %}
    int16_t {{ reg.name | lower }};  /**< {{ reg.description | default(reg.name) }} */
{% elif reg.data_type == "uint32" %}
    uint32_t {{ reg.name | lower }};  /**< {{ reg.description | default(reg.name) }} */
{% elif reg.data_type == "int32" %}
    int32_t {{ reg.name | lower }};  /**< {{ reg.description | default(reg.name) }} */
{% elif reg.data_type == "float32" %}
    float {{ reg.name | lower }};  /**< {{ reg.description | default(reg.name) }} */
{% elif reg.data_type == "enum" %}
    {{ config.device.name | lower }}_{{ reg.enum_type | lower }}_t {{ reg.name | lower }};  /**< {{ reg.description | default(reg.name) }} */
{% else %}
    uint16_t {{ reg.name | lower }};  /**< {{ reg.description | default(reg.name) }} */
{% endif %}
{% endfor %}
} {{ config.device.name | lower }}_holding_registers_t;

{% endif %}
{% if config.stats.num_input_registers > 0 %}
/**
 * @brief Input register data storage
 */
typedef struct {
{% for reg in config.registers.input_registers %}
{% if reg.data_type == "uint16" %}
    uint16_t {{ reg.name | lower }};  /**< {{ reg.description | default(reg.name) }} */
{% elif reg.data_type == "int16" %}
    int16_t {{ reg.name | lower }};  /**< {{ reg.description | default(reg.name) }} */
{% elif reg.data_type == "uint32" %}
    uint32_t {{ reg.name | lower }};  /**< {{ reg.description | default(reg.name) }} */
{% elif reg.data_type == "int32" %}
    int32_t {{ reg.name | lower }};  /**< {{ reg.description | default(reg.name) }} */
{% elif reg.data_type == "float32" %}
    float {{ reg.name | lower }};  /**< {{ reg.description | default(reg.name) }} */
{% elif reg.data_type == "enum" %}
    {{ config.device.name | lower }}_{{ reg.enum_type | lower }}_t {{ reg.name | lower }};  /**< {{ reg.description | default(reg.name) }} */
{% else %}
    uint16_t {{ reg.name | lower }};  /**< {{ reg.description | default(reg.name) }} */
{% endif %}
{% endfor %}
} {{ config.device.name | lower }}_input_registers_t;

{% endif %}
/* ==========================================================================
 * Function Declarations
 * ========================================================================== */

/**
 * @brief Initialize register data with default values
 */
void {{ config.device.name | lower }}_registers_init(void);

{% if config.stats.num_coils > 0 %}
/**
 * @brief Get pointer to coils data structure
 * @return Pointer to coils data
 */
{{ config.device.name | lower }}_coils_t* {{ config.device.name | lower }}_get_coils(void);

{% endif %}
{% if config.stats.num_discrete_inputs > 0 %}
/**
 * @brief Get pointer to discrete inputs data structure
 * @return Pointer to discrete inputs data
 */
{{ config.device.name | lower }}_discrete_inputs_t* {{ config.device.name | lower }}_get_discrete_inputs(void);

{% endif %}
{% if config.stats.num_holding_registers > 0 %}
/**
 * @brief Get pointer to holding registers data structure
 * @return Pointer to holding registers data
 */
{{ config.device.name | lower }}_holding_registers_t* {{ config.device.name | lower }}_get_holding_registers(void);

{% endif %}
{% if config.stats.num_input_registers > 0 %}
/**
 * @brief Get pointer to input registers data structure
 * @return Pointer to input registers data
 */
{{ config.device.name | lower }}_input_registers_t* {{ config.device.name | lower }}_get_input_registers(void);

{% endif %}
#endif /* {{ config.device.name | upper }}_REGISTERS_H */
