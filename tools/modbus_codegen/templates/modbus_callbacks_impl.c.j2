/**
 * @file {{ config.device.name | lower }}_callbacks.c
 * @brief Modbus callback implementations for {{ config.device.name }}
 *
 * This file is auto-generated by modbus_codegen.py
 * You may modify this file to customize callback behavior.
 *
 * Device: {{ config.device.name }}
 * Description: {{ config.device.description | default("") }}
 * Version: {{ config.device.version | default("1.0.0") }}
 *
 * @copyright Copyright (c) 2026
 */

#include "modbus_callbacks.h"
#include "{{ config.device.name | lower }}_registers.h"

/* ==========================================================================
 * Helper Macros
 * ========================================================================== */

/** Check if address is within range */
#define ADDR_IN_RANGE(addr, min, max) (((addr) >= (min)) && ((addr) <= (max)))

/* ==========================================================================
 * Coil Callbacks (FC01, FC05, FC15)
 * ========================================================================== */

{% if config.stats.num_coils > 0 %}
/**
 * @brief Read coils callback (FC01)
 */
modbus_exception_t modbus_cb_read_coils(uint16_t start_address,
                                         uint16_t quantity,
                                         uint8_t* coil_values)
{
    {{ config.device.name | lower }}_coils_t* coils = {{ config.device.name | lower }}_get_coils();
    uint16_t end_address = start_address + quantity - 1U;
    uint16_t byte_index;
    uint16_t bit_index;
    bool value;

    /* Validate address range */
    if (!ADDR_IN_RANGE(start_address, {{ config.device.name | upper }}_COIL_MIN_ADDR,
                       {{ config.device.name | upper }}_COIL_MAX_ADDR) ||
        !ADDR_IN_RANGE(end_address, {{ config.device.name | upper }}_COIL_MIN_ADDR,
                       {{ config.device.name | upper }}_COIL_MAX_ADDR))
    {
        return MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
    }

    /* Clear output buffer */
    for (uint16_t i = 0U; i < ((quantity + 7U) / 8U); i++)
    {
        coil_values[i] = 0U;
    }

    /* Read each coil */
    for (uint16_t i = 0U; i < quantity; i++)
    {
        uint16_t addr = start_address + i;
        value = false;

        switch (addr)
        {
{% for coil in config.registers.coils %}
            case {{ config.device.name | upper }}_COIL_{{ coil.name | upper }}:
                value = coils->{{ coil.name | lower }};
                break;
{% endfor %}
            default:
                return MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
        }

        /* Pack bit into output buffer */
        byte_index = i / 8U;
        bit_index = i % 8U;
        if (value)
        {
            coil_values[byte_index] |= (uint8_t)(1U << bit_index);
        }
    }

    return MODBUS_EXCEPTION_NONE;
}

/**
 * @brief Write single coil callback (FC05)
 */
modbus_exception_t modbus_cb_write_single_coil(uint16_t address, bool value)
{
    {{ config.device.name | lower }}_coils_t* coils = {{ config.device.name | lower }}_get_coils();

    switch (address)
    {
{% for coil in config.registers.coils %}
{% if coil.access is not defined or coil.access == "read_write" %}
        case {{ config.device.name | upper }}_COIL_{{ coil.name | upper }}:
            coils->{{ coil.name | lower }} = value;
            break;
{% endif %}
{% endfor %}
        default:
            return MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
    }

    return MODBUS_EXCEPTION_NONE;
}

/**
 * @brief Write multiple coils callback (FC15)
 */
modbus_exception_t modbus_cb_write_multiple_coils(uint16_t start_address,
                                                   uint16_t quantity,
                                                   const uint8_t* coil_values)
{
    modbus_exception_t result;
    uint16_t byte_index;
    uint16_t bit_index;
    bool value;

    for (uint16_t i = 0U; i < quantity; i++)
    {
        byte_index = i / 8U;
        bit_index = i % 8U;
        value = ((coil_values[byte_index] >> bit_index) & 0x01U) != 0U;

        result = modbus_cb_write_single_coil(start_address + i, value);
        if (result != MODBUS_EXCEPTION_NONE)
        {
            return result;
        }
    }

    return MODBUS_EXCEPTION_NONE;
}

{% else %}
/**
 * @brief Read coils callback (FC01) - No coils defined
 */
modbus_exception_t modbus_cb_read_coils(uint16_t start_address,
                                         uint16_t quantity,
                                         uint8_t* coil_values)
{
    (void)start_address;
    (void)quantity;
    (void)coil_values;
    return MODBUS_EXCEPTION_ILLEGAL_FUNCTION;
}

/**
 * @brief Write single coil callback (FC05) - No coils defined
 */
modbus_exception_t modbus_cb_write_single_coil(uint16_t address, bool value)
{
    (void)address;
    (void)value;
    return MODBUS_EXCEPTION_ILLEGAL_FUNCTION;
}

/**
 * @brief Write multiple coils callback (FC15) - No coils defined
 */
modbus_exception_t modbus_cb_write_multiple_coils(uint16_t start_address,
                                                   uint16_t quantity,
                                                   const uint8_t* coil_values)
{
    (void)start_address;
    (void)quantity;
    (void)coil_values;
    return MODBUS_EXCEPTION_ILLEGAL_FUNCTION;
}

{% endif %}
/* ==========================================================================
 * Discrete Input Callbacks (FC02)
 * ========================================================================== */

{% if config.stats.num_discrete_inputs > 0 %}
/**
 * @brief Read discrete inputs callback (FC02)
 */
modbus_exception_t modbus_cb_read_discrete_inputs(uint16_t start_address,
                                                   uint16_t quantity,
                                                   uint8_t* input_values)
{
    {{ config.device.name | lower }}_discrete_inputs_t* inputs = {{ config.device.name | lower }}_get_discrete_inputs();
    uint16_t end_address = start_address + quantity - 1U;
    uint16_t byte_index;
    uint16_t bit_index;
    bool value;

    /* Validate address range */
    if (!ADDR_IN_RANGE(start_address, {{ config.device.name | upper }}_DI_MIN_ADDR,
                       {{ config.device.name | upper }}_DI_MAX_ADDR) ||
        !ADDR_IN_RANGE(end_address, {{ config.device.name | upper }}_DI_MIN_ADDR,
                       {{ config.device.name | upper }}_DI_MAX_ADDR))
    {
        return MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
    }

    /* Clear output buffer */
    for (uint16_t i = 0U; i < ((quantity + 7U) / 8U); i++)
    {
        input_values[i] = 0U;
    }

    /* Read each input */
    for (uint16_t i = 0U; i < quantity; i++)
    {
        uint16_t addr = start_address + i;
        value = false;

        switch (addr)
        {
{% for di in config.registers.discrete_inputs %}
            case {{ config.device.name | upper }}_DI_{{ di.name | upper }}:
                value = inputs->{{ di.name | lower }};
                break;
{% endfor %}
            default:
                return MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
        }

        /* Pack bit into output buffer */
        byte_index = i / 8U;
        bit_index = i % 8U;
        if (value)
        {
            input_values[byte_index] |= (uint8_t)(1U << bit_index);
        }
    }

    return MODBUS_EXCEPTION_NONE;
}

{% else %}
/**
 * @brief Read discrete inputs callback (FC02) - No discrete inputs defined
 */
modbus_exception_t modbus_cb_read_discrete_inputs(uint16_t start_address,
                                                   uint16_t quantity,
                                                   uint8_t* input_values)
{
    (void)start_address;
    (void)quantity;
    (void)input_values;
    return MODBUS_EXCEPTION_ILLEGAL_FUNCTION;
}

{% endif %}
/* ==========================================================================
 * Holding Register Callbacks (FC03, FC06, FC16)
 * ========================================================================== */

{% if config.stats.num_holding_registers > 0 %}
/**
 * @brief Read holding registers callback (FC03)
 */
modbus_exception_t modbus_cb_read_holding_registers(uint16_t start_address,
                                                     uint16_t quantity,
                                                     uint16_t* register_values)
{
    {{ config.device.name | lower }}_holding_registers_t* regs = {{ config.device.name | lower }}_get_holding_registers();
    uint16_t end_address = start_address + quantity - 1U;

    /* Validate address range */
    if (!ADDR_IN_RANGE(start_address, {{ config.device.name | upper }}_HR_MIN_ADDR,
                       {{ config.device.name | upper }}_HR_MAX_ADDR) ||
        !ADDR_IN_RANGE(end_address, {{ config.device.name | upper }}_HR_MIN_ADDR,
                       {{ config.device.name | upper }}_HR_MAX_ADDR))
    {
        return MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
    }

    /* Read each register */
    for (uint16_t i = 0U; i < quantity; i++)
    {
        uint16_t addr = start_address + i;

        switch (addr)
        {
{% for reg in config.registers.holding_registers %}
{% if reg.size == 1 %}
            case {{ config.device.name | upper }}_HR_{{ reg.name | upper }}:
                register_values[i] = (uint16_t)regs->{{ reg.name | lower }};
                break;
{% elif reg.size == 2 %}
            case {{ config.device.name | upper }}_HR_{{ reg.name | upper }}:
                /* High word of 32-bit value */
{% if reg.data_type == "float32" %}
                {
                    union { float f; uint32_t u; } conv;
                    conv.f = regs->{{ reg.name | lower }};
                    register_values[i] = (uint16_t)(conv.u >> 16U);
                }
{% else %}
                register_values[i] = (uint16_t)((uint32_t)regs->{{ reg.name | lower }} >> 16U);
{% endif %}
                break;
            case {{ config.device.name | upper }}_HR_{{ reg.name | upper }} + 1U:
                /* Low word of 32-bit value */
{% if reg.data_type == "float32" %}
                {
                    union { float f; uint32_t u; } conv;
                    conv.f = regs->{{ reg.name | lower }};
                    register_values[i] = (uint16_t)(conv.u & 0xFFFFU);
                }
{% else %}
                register_values[i] = (uint16_t)((uint32_t)regs->{{ reg.name | lower }} & 0xFFFFU);
{% endif %}
                break;
{% endif %}
{% endfor %}
            default:
                return MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
        }
    }

    return MODBUS_EXCEPTION_NONE;
}

/**
 * @brief Write single register callback (FC06)
 */
modbus_exception_t modbus_cb_write_single_register(uint16_t address, uint16_t value)
{
    {{ config.device.name | lower }}_holding_registers_t* regs = {{ config.device.name | lower }}_get_holding_registers();

    switch (address)
    {
{% for reg in config.registers.holding_registers %}
{% if (reg.access is not defined or reg.access == "read_write") and reg.size == 1 %}
        case {{ config.device.name | upper }}_HR_{{ reg.name | upper }}:
{% if reg.min_value is defined or reg.max_value is defined %}
            /* Validate value range */
{% if reg.min_value is defined %}
            if (value < {{ reg.min_value }}U)
            {
                return MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE;
            }
{% endif %}
{% if reg.max_value is defined %}
            if (value > {{ reg.max_value }}U)
            {
                return MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE;
            }
{% endif %}
{% endif %}
{% if reg.data_type == "int16" %}
            regs->{{ reg.name | lower }} = (int16_t)value;
{% else %}
            regs->{{ reg.name | lower }} = value;
{% endif %}
            break;
{% endif %}
{% endfor %}
        default:
            return MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
    }

    return MODBUS_EXCEPTION_NONE;
}

/**
 * @brief Write multiple registers callback (FC16)
 */
modbus_exception_t modbus_cb_write_multiple_registers(uint16_t start_address,
                                                       uint16_t quantity,
                                                       const uint16_t* register_values)
{
    modbus_exception_t result;

    for (uint16_t i = 0U; i < quantity; i++)
    {
        result = modbus_cb_write_single_register(start_address + i, register_values[i]);
        if (result != MODBUS_EXCEPTION_NONE)
        {
            return result;
        }
    }

    return MODBUS_EXCEPTION_NONE;
}

{% else %}
/**
 * @brief Read holding registers callback (FC03) - No holding registers defined
 */
modbus_exception_t modbus_cb_read_holding_registers(uint16_t start_address,
                                                     uint16_t quantity,
                                                     uint16_t* register_values)
{
    (void)start_address;
    (void)quantity;
    (void)register_values;
    return MODBUS_EXCEPTION_ILLEGAL_FUNCTION;
}

/**
 * @brief Write single register callback (FC06) - No holding registers defined
 */
modbus_exception_t modbus_cb_write_single_register(uint16_t address, uint16_t value)
{
    (void)address;
    (void)value;
    return MODBUS_EXCEPTION_ILLEGAL_FUNCTION;
}

/**
 * @brief Write multiple registers callback (FC16) - No holding registers defined
 */
modbus_exception_t modbus_cb_write_multiple_registers(uint16_t start_address,
                                                       uint16_t quantity,
                                                       const uint16_t* register_values)
{
    (void)start_address;
    (void)quantity;
    (void)register_values;
    return MODBUS_EXCEPTION_ILLEGAL_FUNCTION;
}

{% endif %}
/* ==========================================================================
 * Input Register Callbacks (FC04)
 * ========================================================================== */

{% if config.stats.num_input_registers > 0 %}
/**
 * @brief Read input registers callback (FC04)
 */
modbus_exception_t modbus_cb_read_input_registers(uint16_t start_address,
                                                   uint16_t quantity,
                                                   uint16_t* register_values)
{
    {{ config.device.name | lower }}_input_registers_t* regs = {{ config.device.name | lower }}_get_input_registers();
    uint16_t end_address = start_address + quantity - 1U;

    /* Validate address range */
    if (!ADDR_IN_RANGE(start_address, {{ config.device.name | upper }}_IR_MIN_ADDR,
                       {{ config.device.name | upper }}_IR_MAX_ADDR) ||
        !ADDR_IN_RANGE(end_address, {{ config.device.name | upper }}_IR_MIN_ADDR,
                       {{ config.device.name | upper }}_IR_MAX_ADDR))
    {
        return MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
    }

    /* Read each register */
    for (uint16_t i = 0U; i < quantity; i++)
    {
        uint16_t addr = start_address + i;

        switch (addr)
        {
{% for reg in config.registers.input_registers %}
{% if reg.size == 1 %}
            case {{ config.device.name | upper }}_IR_{{ reg.name | upper }}:
                register_values[i] = (uint16_t)regs->{{ reg.name | lower }};
                break;
{% elif reg.size == 2 %}
            case {{ config.device.name | upper }}_IR_{{ reg.name | upper }}:
                /* High word of 32-bit value */
{% if reg.data_type == "float32" %}
                {
                    union { float f; uint32_t u; } conv;
                    conv.f = regs->{{ reg.name | lower }};
                    register_values[i] = (uint16_t)(conv.u >> 16U);
                }
{% else %}
                register_values[i] = (uint16_t)((uint32_t)regs->{{ reg.name | lower }} >> 16U);
{% endif %}
                break;
            case {{ config.device.name | upper }}_IR_{{ reg.name | upper }} + 1U:
                /* Low word of 32-bit value */
{% if reg.data_type == "float32" %}
                {
                    union { float f; uint32_t u; } conv;
                    conv.f = regs->{{ reg.name | lower }};
                    register_values[i] = (uint16_t)(conv.u & 0xFFFFU);
                }
{% else %}
                register_values[i] = (uint16_t)((uint32_t)regs->{{ reg.name | lower }} & 0xFFFFU);
{% endif %}
                break;
{% endif %}
{% endfor %}
            default:
                return MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
        }
    }

    return MODBUS_EXCEPTION_NONE;
}

{% else %}
/**
 * @brief Read input registers callback (FC04) - No input registers defined
 */
modbus_exception_t modbus_cb_read_input_registers(uint16_t start_address,
                                                   uint16_t quantity,
                                                   uint16_t* register_values)
{
    (void)start_address;
    (void)quantity;
    (void)register_values;
    return MODBUS_EXCEPTION_ILLEGAL_FUNCTION;
}

{% endif %}
